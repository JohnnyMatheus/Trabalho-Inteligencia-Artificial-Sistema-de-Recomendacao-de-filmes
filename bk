import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler
import streamlit as st
import os

# ==============================
# 1. Carregar dados
# ==============================
@st.cache_data
def load_data():
    csv_path = "imdb-top-rated-movies-user-rated.csv"
    if not os.path.exists(csv_path):
        st.error(f"Arquivo CSV n√£o encontrado em: {os.path.abspath(csv_path)}")
        return pd.DataFrame()
    df = pd.read_csv(csv_path)
    return df

df = load_data()

st.title("üé¨ Sistema de Recomenda√ß√£o de Filmes (RBC)")
st.write("Base de dados carregada:", df.shape[0], "filmes")

# Mostrar primeiras linhas para debug
if st.checkbox("Mostrar dados brutos"):
    st.dataframe(df.head())

# ==============================
# 2. Pr√©-processamento
# ==============================
if df.empty:
    st.warning("‚ö†Ô∏è Base de dados vazia. Importe o CSV correto para prosseguir.")
else:
    # Limpeza de votos
    def clean_votes(vote_str):
        if pd.isna(vote_str):
            return 0
        try:
            if 'K' in str(vote_str):
                return float(str(vote_str).replace('K', '')) * 1000
            else:
                return float(vote_str)
        except:
            return 0

    df['Votes_Clean'] = df['Votes'].apply(clean_votes) if 'Votes' in df.columns else 0
    df['Year_Extracted'] = pd.to_numeric(df['Title'].str.extract(r'\((\d{4})\)')[0], errors='coerce').fillna(0).astype(int)
    
    # Features num√©ricas
    features = []
    for col in ['IMDb Rating', 'Meta Score', 'Votes_Clean', 'Year_Extracted']:
        if col in df.columns or col in ['Votes_Clean', 'Year_Extracted']:
            features.append(col)
    
    # ==============================
    # One-hot encoding de g√™neros
    # ==============================
    if 'Genre' in df.columns:
        generos_unicos = set()
        for g in df['Genre'].dropna():
            generos_unicos.update([x.strip() for x in g.split(',')])
        generos_unicos = sorted(list(generos_unicos))
        
        for genero in generos_unicos:
            df[genero] = df['Genre'].apply(lambda x: 1 if pd.notna(x) and genero in x else 0)
            features.append(genero)
    
    # Normalizar
    df_proc = df[features].fillna(0)
    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df_proc)
    
    st.success("‚úÖ Dados processados com sucesso!")
    st.write("Estat√≠sticas das features num√©ricas:")
    st.write(df_proc.describe())

# ==============================
# 3. Fun√ß√£o de recomenda√ß√£o (RBC)
# ==============================
def recomendar_filmes(nome_filme, top_k=5):
    try:
        mask = df['Title'].str.lower().str.contains(nome_filme.lower(), na=False)
        if not mask.any():
            return None, "Filme n√£o encontrado na base de dados.", None, None
        
        idx = df[mask].index[0]
        
        # Vetor de similaridade
        sim_scores = cosine_similarity([df_scaled[idx]], df_scaled)[0]
        
        # Filtrar apenas filmes com pelo menos 1 g√™nero em comum
        if 'Genre' in df.columns and pd.notna(df.iloc[idx]['Genre']):
            generos_base = set(df.iloc[idx]['Genre'].split(', '))
            mask_genero = df['Genre'].apply(lambda x: len(set(x.split(', ')) & generos_base) > 0 if pd.notna(x) else False)
            sim_scores = sim_scores * mask_genero.astype(int)
        
        # √çndices dos filmes mais similares (exceto o pr√≥prio)
        indices = np.argsort(sim_scores)[::-1][1:top_k+1]
        
        colunas_disp = ['Title', 'Year_Extracted', 'IMDb Rating']
        if 'Genre' in df.columns:
            colunas_disp.append('Genre')
        
        recomendados = df.iloc[indices][colunas_disp]
        filme_original = df.iloc[idx][colunas_disp]

        return filme_original, recomendados, sim_scores, indices
    except Exception as e:
        return None, f"Erro na recomenda√ß√£o: {e}", None, None

# ==============================
# 4. Interface Streamlit
# ==============================
if not df.empty:
    st.subheader("üîç Buscar Recomenda√ß√µes")
    
    filmes_disponiveis = df['Title'].sort_values().tolist()
    filme_selecionado = st.selectbox("Selecione um filme:", filmes_disponiveis, index=0)
    top_k = st.slider("N√∫mero de recomenda√ß√µes:", min_value=3, max_value=10, value=5)
    
    if st.button("Buscar Recomenda√ß√µes"):
        if filme_selecionado:
            with st.spinner("Buscando recomenda√ß√µes..."):
                filme_original, recomendacoes, sim_scores, indices = recomendar_filmes(filme_selecionado, top_k)
                
                if filme_original is not None and recomendacoes is not None:
                    st.success(f"üéØ Filme base: **{filme_original['Title']}** ({filme_original['Year_Extracted']})")
                    st.write(f"‚≠ê Rating: {filme_original['IMDb Rating']}" + (f" | üè∑Ô∏è G√™nero: {filme_original['Genre']}" if 'Genre' in filme_original else ""))
                    
                    # Mostrar a f√≥rmula usada
                    st.subheader("üìê F√≥rmula da Similaridade do Cosseno")
                    st.latex(r"""
                    \text{similaridade}(A,B) = 
                    \frac{\sum_{i=1}^n A_i \cdot B_i}
                    {\sqrt{\sum_{i=1}^n A_i^2} \cdot \sqrt{\sum_{i=1}^n B_i^2}}
                    """)
                    st.caption("A representa o vetor de caracter√≠sticas do filme base e B representa outro filme da base.")

                    st.subheader("üé¨ Filmes Recomendados:")
                    for i, (rec_idx, (_, filme)) in enumerate(zip(indices, recomendacoes.iterrows()), 1):
                        score = sim_scores[rec_idx]
                        col1, col2, col3 = st.columns([3,1,1])
                        with col1:
                            st.write(f"**{i}. {filme['Title']}** ({filme['Year_Extracted']})")
                            if 'Genre' in filme:
                                st.caption(f"G√™nero: {filme['Genre']}")
                        with col2:
                            st.metric("Rating", filme['IMDb Rating'])
                        with col3:
                            st.metric("Similaridade", f"{score:.3f}")
                        st.divider()
                else:
                    st.error(recomendacoes)

# ==============================
# 5. Sidebar
# ==============================
if not df.empty:
    st.sidebar.header("‚ÑπÔ∏è Sobre o Sistema")
    st.sidebar.write("""
    Sistema baseado em **Racioc√≠nio Baseado em Casos (RBC)**.
    Similaridade baseada em:
    - ‚≠ê Avalia√ß√£o IMDb
    - üèÜ Meta Score
    - üë• N√∫mero de votos
    - üìÖ Ano de lan√ßamento
    - üé≠ G√™nero
    """)

    st.sidebar.header("üìä Estat√≠sticas")
    st.sidebar.metric("Total de Filmes", df.shape[0])
    if 'IMDb Rating' in df.columns:
        st.sidebar.metric("Rating M√©dio", f"{df['IMDb Rating'].mean():.1f}")

    try:
        votes_max = df['Votes_Clean'].max() if 'Votes_Clean' in df.columns else 0
        if votes_max >= 1_000_000:
            votes_text = f"{votes_max/1_000_000:.1f}M votos"
        elif votes_max >= 1_000:
            votes_text = f"{votes_max/1_000:.0f}K votos"
        else:
            votes_text = f"{votes_max:.0f} votos"
        st.sidebar.metric("Filme Mais Votado", votes_text)
    except:
        st.sidebar.metric("Filme Mais Votado", "N/A")

    # Explorar por g√™nero
    if 'Genre' in df.columns:
        st.sidebar.header("üé≠ Explorar por G√™nero")
        todos_generos = []
        for generos in df['Genre'].dropna():
            generos_split = [g.strip() for g in generos.split(',')]
            todos_generos.extend(generos_split)
        generos_disponiveis = sorted(set(todos_generos))
        genero_selecionado = st.sidebar.selectbox("Selecione um g√™nero:", generos_disponiveis)
        if genero_selecionado:
            filmes_genero = df[df['Genre'].str.contains(genero_selecionado, na=False)].nlargest(5, 'IMDb Rating')
            st.sidebar.write(f"**Top 5 {genero_selecionado}:**")
            for _, filme in filmes_genero.iterrows():
                st.sidebar.write(f"‚Ä¢ {filme['Title']} ({filme['IMDb Rating']}‚≠ê)")
